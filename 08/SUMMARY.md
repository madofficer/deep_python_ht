# Замеры скорости в `memory_profiler.py`
![Замеры скорости и времени](output_log.png)

На скриншоте видно распределение по скорости, использованных способов:
1) Слабая ссылка с помощью `weakref`
2) Дефолтное создание экземпляров класса
3) Использование магического метода `__slots__`.

Распределение по памяти выглядит иначе:
1) `__slots__`
2) Обыкновенный способ
3) Слабые ссылки

Скорость чтение и модификации:
1) `__slots__`
2) Обыкновенный способ
3) Слабые ссылки

*Получены ожидаемые результаты, однако для оптимизации параметр `numbers=1` и профилирование показывает время с некой
незначительной погрешностью, тк машина выполняет код по-разному.*

*Если важна скорость и в дальнейшем не нужно модифицировать класс, то слабые ссылки могут выручить.
Для экономии памяти однозначно лучше использовать слоты, но нужно знать заранее количество полей.
Для удобства написания кода без преимуществ по памяти или скорости,
но без ограничений следует прибегнуть к стандартной имплементации.*


